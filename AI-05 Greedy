
A. Selection Sort (Greedy)
def selection_sort(arr):
    n = len(arr)
    
    for i in range(n):
        min_idx = i
        for j in range(i + 1, n):
            if arr[j] < arr[min_idx]:
                min_idx = j
        
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
    
    return arr

# Example
print(selection_sort([64, 25, 12, 22, 11]))


B. Prim’s Algorithm (MST)
import heapq

def prim_mst(graph, start):
    visited = set()
    pq = [(0, start)]
    total_cost = 0

    while pq:
        cost, node = heapq.heappop(pq)

        if node in visited:
            continue

        visited.add(node)
        total_cost += cost

        for neighbor, weight in graph[node]:
            if neighbor not in visited:
                heapq.heappush(pq, (weight, neighbor))

    return total_cost


graph = {
    'A': [('B', 2), ('C', 3)],
    'B': [('A', 2), ('D', 4)],
    'C': [('A', 3), ('D', 1)],
    'D': [('B', 4), ('C', 1)],
}

print("MST cost (Prim):", prim_mst(graph, 'A'))


C. Kruskal’s Algorithm (MST)
# Kruskal's MST using Disjoint Set (Union-Find)

class DSU:
    def __init__(self, n):
        self.parent = list(range(n))
    
    def find(self, x):
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]
    
    def union(self, a, b):
        pa = self.find(a)
        pb = self.find(b)
        if pa != pb:
            self.parent[pa] = pb


def kruskal_mst(edges, n):
    dsu = DSU(n)
    mst_cost = 0

    edges.sort(key=lambda x: x[2])  # sort by weight

    for u, v, w in edges:
        if dsu.find(u) != dsu.find(v):
            dsu.union(u, v)
            mst_cost += w

    return mst_cost


edges = [
    (0, 1, 2),
    (0, 2, 3),
    (1, 3, 4),
    (2, 3, 1)
]

print("MST cost (Kruskal):", kruskal_mst(edges, 4))

D. Dijkstra’s Algorithm (Shortest Path)
import heapq

def dijkstra(graph, start):
    pq = [(0, start)]
    dist = {node: float('inf') for node in graph}
    dist[start] = 0

    while pq:
        cost, node = heapq.heappop(pq)

        for neighbor, weight in graph[node]:
            new_cost = cost + weight
            if new_cost < dist[neighbor]:
                dist[neighbor] = new_cost
                heapq.heappush(pq, (new_cost, neighbor))

    return dist


graph = {
    'A': [('B', 1), ('C', 4)],
    'B': [('C', 2), ('D', 5)],
    'C': [('D', 1)],
    'D': []
}

print("Shortest paths:", dijkstra(graph, 'A'))
