import heapq

# Graph with actual costs
graph = {
    'A': {'B': 1, 'C': 4},
    'B': {'D': 2, 'E': 5},
    'C': {'F': 3},
    'D': {},
    'E': {'G': 2},
    'F': {'G': 5},
    'G': {}
}

# Heuristic values (estimated distance to goal 'G')
h = {
    'A': 7,
    'B': 6,
    'C': 4,
    'D': 4,
    'E': 2,
    'F': 6,
    'G': 0
}


# ---------------- Best First Search ----------------
def best_first_search(start, goal):
    pq = []
    heapq.heappush(pq, (h[start], start))
    visited = set()

    while pq:
        cost, node = heapq.heappop(pq)
        print(node, end=" ")

        if node == goal:
            return
        
        visited.add(node)

        for neighbor in graph[node]:
            if neighbor not in visited:
                heapq.heappush(pq, (h[neighbor], neighbor))


# ---------------- A* Search ----------------
def a_star(start, goal):
    pq = []
    heapq.heappush(pq, (h[start], start, 0))  # f(n), node, g(n)
    visited = set()

    while pq:
        f, node, g = heapq.heappop(pq)
        print(node, end=" ")

        if node == goal:
            return
        
        visited.add(node)

        for neighbor in graph[node]:
            new_g = g + graph[node][neighbor]  # actual cost
            new_f = new_g + h[neighbor]        # f = g + h

            if neighbor not in visited:
                heapq.heappush(pq, (new_f, neighbor, new_g))


# Run the algorithms
print("Best First Search Traversal:")
best_first_search('A', 'G')

print("\nA* Traversal:")
a_star('A', 'G')
